<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Execution Patterns</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Promesa</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1 "><a href="promises.html"><div class="inner"><span>Working with Promises</span></div></a></li><li class="depth-1 "><a href="executors.html"><div class="inner"><span>Scheduling &amp; Executors</span></div></a></li><li class="depth-1  current"><a href="patterns.html"><div class="inner"><span>Execution Patterns</span></div></a></li><li class="depth-1 "><a href="contributing.html"><div class="inner"><span>Contributing</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>promesa</span></div></div></li><li class="depth-2 branch"><a href="promesa.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="promesa.exec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exec</span></div></a></li><li class="depth-3 branch"><a href="promesa.exec.bulkhead.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bulkhead</span></div></a></li><li class="depth-3"><a href="promesa.exec.csp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csp</span></div></a></li><li class="depth-2"><a href="promesa.protocols.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#execution-patterns" id="execution-patterns"></a>Execution Patterns</h1>
<h2><a href="#channels-csp" id="channels-csp"></a>Channels (CSP)</h2>
<p>A <a href="https://github.com/clojure/core.async">core.async</a> alternative implementation that laverages JDK19 Virtual Threads; therefore, it is mainly available in the JVM. It combines a new and simplified channel implementation, JDK virtual thrads and composability of promises (CompletableFutureâ€™s).</p>
<p>There are <a href="https://github.com/funcool/promesa/blob/master/doc/csp-walkthrought.clj">Code Walkthrought</a> where you can learn the main API usage patterns. Also, you can read the <a href="https://clojure.org/news/2013/06/28/clojure-clore-async-channels">core.async rationale</a> for better understanding the main ideas of the CSP pattern.</p>
<p>The main highlights and differences with <a href="https://github.com/clojure/core.async">core.async</a> are:</p>
<ul>
<li><strong>There are no macro transformations</strong>, the <code>go</code> macro is a convenient alias for <code>p/vthread</code> (or <code>p/thread</code> when vthreads are not available); there are not limitation on using blocking calls inside <code>go</code> macro neither many other inconveniences of core.async go macro, mainly thanks to the JDK19 with preview enabled Virtual Threads.</li>
<li><strong>No callbacks</strong>, functions returns promises or blocks.</li>
<li><strong>No take/put limits</strong>; you can attach more than 1024 pending tasks to a channel.</li>
<li><strong>Simplier mental model</strong>, there are no differences between parking and blocking operations.</li>
<li><strong>Analgous performance</strong>; in my own stress tests it has the same performance as core.async.</li>
</ul>
<p>There are also some internal differences that you should know:</p>
<ul>
<li>The promesa implementation cancells immediatelly all pending puts when channel is closed in contrast to core.async that leaves them operative until all puts are succeded.</li>
<li>The promesa implementation takes a bit less grandular locking than core.async, but on the end it should not have any effect on the final performance or usability.</li>
</ul>
<p><strong>The promesa channel and csp patterns implementation do not intend to be a replacement for core.async; and there are cases where <a href="https://github.com/clojure/core.async">core.async</a> is preferable; the main usage target for promesa channels and csp patterns implementation is for JVM based backends with JDK&gt;=19.</strong></p>
<p><strong>Although the main focus is the use in JVM, where is all the potential; the channel implementation and all internal buffers are implemented in CLJC. This means that, if there is interest, we can think about exposing channels api using promises. In any case, <em>the usefulness of channel implementation in CLJS remains to be seen.</em></strong></p>
<h2><a href="#bulkhead" id="bulkhead"></a>Bulkhead</h2>
<p>In general, the goal of the bulkhead pattern is to avoid faults in one part of a system to take the entire system down. The bulkhead implementation in <strong>promesa</strong> limits the number of concurrent calls.</p>
<p>This <a href="https://stackoverflow.com/questions/30391809/what-is-bulkhead-pattern-used-by-hystrix">SO answer</a> explains the concept very well.</p>
<p>So lets stat with an example:</p>
<pre><code class="language-clojure">(require '[promesa.exec.bulkhead :as pxb]
         '[promesa.exec :as px])

;; All parameters are optional and have default value
(def instance (pxb/create :concurrency 1
                          :queue-size 16
                          :executor px/*default-executor*))

@(px/submit! instance (fn []
                        (Thread/sleep 1000)
                        1))
;; =&gt; 1
</code></pre>
<p>At first glance, this seems like an executor instance because it resembles the same API (aka `px/submit! call).</p>
<p>When you submits a task to it, it does the following:</p>
<ul>
<li>Checkes if concurrency limit is not reached, if not, proceed to execute the function in the underlying executor.</li>
<li>If concurrency limit is reached, it queues the execution until other tasks are finished.</li>
<li>If queue limit is reached, the returned promise will be automatically rejected with an exception indicating that queue limit reached.</li>
</ul>
<p>This allows control the concurrency and the queue size on access to some resource.</p>
<p>NOTES:</p>
<ul>
<li><em>As future improvements we consider adding an option for delimit the <strong>max wait</strong> and cancel/reject tasks after some timeout.</em></li>
<li><em>For now it is implemented only on JVM but I think is pretty easy to implement on CLJS, so if there are some interest on it, feel free to open and issue for just show interest or discuss how it can be contributed.</em></li>
</ul>
</div></div></div></body></html>