<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Andrey Antukh, &lt;niwi@niwi.nz&gt;">
<title>promesa - promise library for clojure and clojurescript</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://www.niwi.nz/_assets/asciidoctor-styles/simple-red-titles/stylesheet.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>promesa - promise library for clojure and clojurescript</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh, &lt;niwi@niwi.nz&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#project-maturity">Project Maturity</a></li>
<li><a href="#install">Install</a></li>
</ul>
</li>
<li><a href="#user-guide">User guide</a>
<ul class="sectlevel2">
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#creating-a-promise">Creating a promise</a></li>
<li><a href="#promise-chaining">Promise Chaining</a></li>
<li><a href="#promise-composition">Promise Composition</a></li>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#delays-and-timeouts">Delays and timeouts.</a></li>
<li><a href="#scheduling-tasks">Scheduling Tasks</a></li>
</ul>
</li>
<li><a href="#advanced-topics">Advanced topics</a>
<ul class="sectlevel2">
<li><a href="#execution-model">Execution model</a></li>
<li><a href="#performance-overhead">Performance overhead</a></li>
</ul>
</li>
<li><a href="#developers-guide">Developers Guide</a>
<ul class="sectlevel2">
<li><a href="#contributing">Contributing</a></li>
<li><a href="#get-the-code">Get the Code</a></li>
<li><a href="#run-tests">Run tests</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A promise library for Clojure and ClojureScript.</p>
</div>
<div class="paragraph">
<p>On the JVM paltform <em>promesa</em> is built on top of <strong>completable futures</strong>
(requires jdk&gt;=8). On JS engines it is built on top of the execution
environment built-in Promise implementation.</p>
</div>
<div class="sect2">
<h3 id="project-maturity"><a class="link" href="#project-maturity">Project Maturity</a></h3>
<div class="paragraph">
<p>Since <em>promesa</em> is a young project there may be some API breakage.</p>
</div>
</div>
<div class="sect2">
<h3 id="install"><a class="link" href="#install">Install</a></h3>
<div class="paragraph">
<p>Just include the following lines in your dependency vector on <strong><em>project.clj</em></strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">[</span><span class="tok-nv">funcool/promesa</span> <span class="tok-s">&quot;4.0.0&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This package requires JDK &gt;= 8 if you are using it on the JVM.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="user-guide"><a class="link" href="#user-guide">User guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introduction-2"><a class="link" href="#introduction-2">Introduction</a></h3>
<div class="paragraph">
<p>A promise is an abstraction that represents the result of an asynchronous
operation that has the notion of error.</p>
</div>
<div class="paragraph">
<p>This is a list of all possible states for a promise:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>resolved</code>: means that the promise contains a value.</p>
</li>
<li>
<p><code>rejected</code>: means that the promise contains an error.</p>
</li>
<li>
<p><code>pending</code>: means that the promise does not have value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The promise can be considered <strong>done</strong> when it is resolved or rejected.</p>
</div>
</div>
<div class="sect2">
<h3 id="creating-a-promise"><a class="link" href="#creating-a-promise">Creating a promise</a></h3>
<div class="paragraph">
<p>There are several different ways to create a promise instance. If you
just want to create a promise with a value, you can use the <code>promise</code>
function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-c1">;; creates a promise from value</span>
<span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">1</span><span class="tok-p">)</span>

<span class="tok-c1">;; creates a rejected promise</span>
<span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;error&quot;</span> <span class="tok-p">{}))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>promise</code> consturctor function automatcially coerce the value to
the approprite promise, returning rejected promises for exceptions and
resolved promises for the rest of values.</p>
</div>
<div class="paragraph">
<p>If you already known the value and want to create resolved or rejected
promise instances, yo can use <code>resolved</code> and <code>rejected</code> functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">p</span><span class="tok-p">])</span>

<span class="tok-c1">;; Create a resolved promise</span>
<span class="tok-p">(</span><span class="tok-nf">p/resoved</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Promise [~]&gt;</span>

<span class="tok-c1">;; Create a rejected promise</span>
<span class="tok-p">(</span><span class="tok-nf">p/rejected</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;error&quot;</span> <span class="tok-p">{}))</span>
<span class="tok-c1">;; =&gt; #&lt;Promise [~]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>They are more performant because they does not perform any polimorphic
coercion on the value. They create the promise with the provided value
as-is.</p>
</div>
<div class="paragraph">
<p>Another option is to create an empty promise using the <code>deferred</code> function
and provide the value asynchronously using <code>p/resolve!</code> and <code>p/reject!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">sleep</span>
  <span class="tok-p">[</span><span class="tok-nv">ms</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">p/deferred</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nf">js/setTimeout</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">p/resolve!</span> <span class="tok-nv">p</span><span class="tok-p">))</span>
    <span class="tok-nv">p</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is using a factory function. If you are familiar with
JavaScript, there is a similar approach.</p>
</div>
<div class="listingblock">
<div class="title">Example creating a promise instance using a factory.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/create</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">resolve </span><span class="tok-mi">1</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The factory will be executed synchronously (in the current thread) but
if you want to execute it asynchronously, you can provide an executor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.exec</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>

<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/create</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">resolve </span><span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-nv">exec/default-executor</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to create a promise is to use the <code>do!</code> macro. The <code>do!</code>
macro works similarly to the factory callback, except that we can
return a value directly instead of calling <code>resolve</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">p/do!</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nb">rand-int </span><span class="tok-mi">10</span><span class="tok-p">)</span>
        <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nb">rand-int </span><span class="tok-mi">10</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>do!</code> expression work similarly to clojure&#8217;s <code>do</code> block, so you
can provide any expression, but only the last one will be
returned. That expression can be a plain value or an other promise.</p>
</div>
<div class="paragraph">
<p>If an exception is raised inside the <code>do!</code> block, it will return the
rejected promise instead of re-raising the exception on the stack.</p>
</div>
<div class="paragraph">
<p>If the <code>do!</code> contains more than one expression, each expression will
be treated as a promise expression and will be executed sequentially,
each awaiting the resolution of the prior expression.</p>
</div>
<div class="paragraph">
<p>For example, this <code>do!</code> macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">p/do!</span> <span class="tok-p">(</span><span class="tok-nf">expr1</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nf">expr2</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nf">expr3</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Is roughtly equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">p/let</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-p">(</span><span class="tok-nf">expr1</span><span class="tok-p">)</span>
        <span class="tok-nv">_</span> <span class="tok-p">(</span><span class="tok-nf">expr2</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nf">expr3</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, <strong>promesa</strong> exposes a <code>future</code> macro very similar to the
<code>clojure.core/future</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/future</span> <span class="tok-p">(</span><span class="tok-nf">some-complex-task</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; &quot;result-of-complex-task&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One difference from <code>clojure.core/future</code> is that if the return value
of the future expression is itself a promise instance, then it will
await and unwrap the inner promise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/future</span> <span class="tok-p">(</span><span class="tok-nf">p/future</span> <span class="tok-p">(</span><span class="tok-nf">p/future</span> <span class="tok-mi">1</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-chaining"><a class="link" href="#promise-chaining">Promise Chaining</a></h3>
<div class="paragraph">
<p>The most common way to apply a function to a promise (or in other
words, to chain its execution) is using the well-known <code>map</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span>
  <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">p/resolved</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nf">p/map</span> <span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-o">@</span><span class="tok-nv">result</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For people coming from the JS world, there is also the <code>then</code> function
that works in very similar way to <code>map</code> with the exception that the
parameters have different order and flatten automatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/resolved</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-c1">;; flatten result</span>
<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/resolved</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">p/resolved</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">)))))</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to apply multiple functions instead of using multiple
<code>then</code> or <code>map`s, you can use the `chain</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span>
  <span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/resolved</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">p/chain</span> <span class="tok-nb">inc inc </span><span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-o">@</span><span class="tok-nv">result</span>
<span class="tok-c1">;; =&gt; 4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>chain</code> function uses <code>then</code> behind the scenes, so the same rules
about flattening applies.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
if you know that your chained functions do not return promises,
you can use <code>chain'</code> instead for better performance.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="promise-composition"><a class="link" href="#promise-composition">Promise Composition</a></h3>
<div class="sect3">
<h4 id="let"><a class="link" href="#let"><code>let</code></a></h4>
<div class="paragraph">
<p>The <em>promesa</em> library comes with convenient syntactic-sugar that allows
you to create a composition that looks like synchronous code while
using the clojure&#8217;s familiar <code>let</code> syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.exec</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">sleep-promise</span>
  <span class="tok-p">[</span><span class="tok-nv">wait</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nf">exec/schedule!</span> <span class="tok-nv">wait</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">resolve </span><span class="tok-nv">wait</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span>
  <span class="tok-p">(</span><span class="tok-nf">p/let</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
          <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
          <span class="tok-nv">z</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">z</span><span class="tok-p">)))</span>

<span class="tok-o">@</span><span class="tok-nv">result</span>
<span class="tok-c1">;; =&gt; 85</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>let</code> macro behaves identically to the <code>let</code> with the exception
that it always return a promise.</p>
</div>
<div class="paragraph">
<p>If an error occurs at any step, the entire composition will be
short-circuited, returning exceptionally resolved promise.</p>
</div>
<div class="paragraph">
<p>Under the hood, the previous <code>let</code> macro evalutes to something like
this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
                        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-mi">2</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">z</span><span class="tok-p">]</span>
                                            <span class="tok-p">(</span><span class="tok-nf">p/resolved</span> <span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">z</span><span class="tok-p">)))))))))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="all"><a class="link" href="#all"><code>all</code></a></h4>
<div class="paragraph">
<p>In some circumstances you will want wait for completion of several promises at
the same time. To help with that, <em>promesa</em> also provides helpers.</p>
</div>
<div class="paragraph">
<p>Imagine that you have a collection of promises and you want to wait until all of
them are resolved. This can be done using the <code>all</code> combinator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">p/all</span> <span class="tok-p">[(</span><span class="tok-nf">do-some-io</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">do-some-other-io</span><span class="tok-p">)])]</span>
  <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[[</span><span class="tok-nv">result1</span> <span class="tok-nv">result2</span><span class="tok-p">]]</span>
              <span class="tok-p">(</span><span class="tok-nf">do-something-with-results</span> <span class="tok-nv">result1</span> <span class="tok-nv">result2</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="plet"><a class="link" href="#plet"><code>plet</code></a></h4>
<div class="paragraph">
<p>The <code>plet</code> macro combines syntax of <code>let</code> with <code>all</code>. It enables a simple
declaration of parallel operations followed by a body expression that
will be executed when all parallel operations have successfully
resolved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/plet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
          <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">200</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
          <span class="tok-nv">c</span> <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">120</span> <span class="tok-mi">3</span><span class="tok-p">)]</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">na</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; result: 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>plet</code> macro is just a syntactic sugar on top of <code>all</code>. The previous example
can be written using <code>all</code> in this manner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">p/all</span> <span class="tok-p">[(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">200</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">120</span> <span class="tok-mi">3</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">]]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="any"><a class="link" href="#any"><code>any</code></a></h4>
<div class="paragraph">
<p>There are also circumstances where you only want the first successfully resolved
promise. For this case, you can use the <code>any</code> combinator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-nf">p/any</span> <span class="tok-p">[(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">200</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">120</span> <span class="tok-mi">3</span><span class="tok-p">)])]</span>
  <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">p</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
              <span class="tok-p">(</span><span class="tok-nf">.log</span> <span class="tok-nv">js/console</span> <span class="tok-s">&quot;The first one finished: &quot;</span> <span class="tok-nv">x</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="race"><a class="link" href="#race"><code>race</code></a></h4>
<div class="paragraph">
<p>The <code>race</code> function method returns a promise that fulfills or rejects
as soon as one of the promises in an iterable fulfills or rejects,
with the value or reason from that promise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/race</span> <span class="tok-p">[(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
          <span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">110</span> <span class="tok-mi">2</span><span class="tok-p">)])</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error-handling"><a class="link" href="#error-handling">Error handling</a></h3>
<div class="paragraph">
<p>One of the advantages of using the promise abstraction is that it natively has a notion
of errors, so you don&#8217;t need reinvent it. If some computation inside the composed
promise chain/pipeline raises an exception, the pipeline short-circuits and propogates
the exception to the last promise in the chain.</p>
</div>
<div class="paragraph">
<p>Let see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/rejected</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;error&quot;</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nf">p/catch</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">error</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nf">.log</span> <span class="tok-nv">js/console</span> <span class="tok-nv">error</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>catch</code> function adds a new handler to the promise chain that will be called
when any of the previous promises in the chain are rejected or an exception is
raised. The <code>catch</code> function also returns a promise that will be resolved or
rejected depending on that will happen inside the catch handler.</p>
</div>
<div class="paragraph">
<p>If you prefer <code>map</code>-like parameters order, the <code>err</code> function (and <code>error</code>
alias) works in same way as <code>catch</code> but has parameters ordered like <code>map</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">p/rejected</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;error&quot;</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
     <span class="tok-p">(</span><span class="tok-nf">p/error</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">error</span><span class="tok-p">]</span>
                <span class="tok-p">(</span><span class="tok-nf">.log</span> <span class="tok-nv">js/console</span> <span class="tok-nv">error</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>On the JVM platform the reject value must be an instance of <code>Throwable</code>, but on
the JavaScript platform the reject value can be any value.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="delays-and-timeouts"><a class="link" href="#delays-and-timeouts">Delays and timeouts.</a></h3>
<div class="paragraph">
<p>JavaScript, due its single-threaded nature, does not allow you to block or
sleep. But, with promises you can emulate that functionality using <code>delay</code> like
so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">1000</span> <span class="tok-s">&quot;foobar&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Received:&quot;</span> <span class="tok-nv">v</span><span class="tok-p">))))</span>

<span class="tok-c1">;; After 1 second it will print the message</span>
<span class="tok-c1">;; to the console: &quot;Received: foobar&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The promise library also offers the ability to add a timeout to async
operations thanks to the <code>timeout</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">some-async-task</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">p/timeout</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Task finished&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nf">p/catch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Timeout&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, if the async task takes more that 200ms then the promise will
be rejected with a timeout error and then successfully captured with the <code>catch</code>
handler.</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-tasks"><a class="link" href="#scheduling-tasks">Scheduling Tasks</a></h3>
<div class="paragraph">
<p>In addition to the promise abstraction, this library also comes with a
lightweight abstraction for scheduling task to be executed at some
time in future:</p>
</div>
<div class="listingblock">
<div class="title">Example using the <code>schedule</code> function.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.exec</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">exec/schedule!</span> <span class="tok-mi">1000</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hello world&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This example shows you how you can schedule a function call to be
executed 1 second in the future. It works the same way for both
plaforms (clj and cljs).</p>
</div>
<div class="paragraph">
<p>The tasks can be cancelled using its return value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">task</span> <span class="tok-p">(</span><span class="tok-nf">exec/schedule!</span> <span class="tok-mi">1000</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">do-stuff</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">p/cancel!</span> <span class="tok-nv">task</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-topics"><a class="link" href="#advanced-topics">Advanced topics</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="execution-model"><a class="link" href="#execution-model">Execution model</a></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This section is mainly affects the <strong>JVM</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lets take this example as a context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create a promise that will resolve to <code>1</code> in 100ms (in a
separated thread); then the first <code>inc</code> will be executed (in the same
thread) and then another <code>inc</code> is executed (in the same
thread). In total only one thread is involved.</p>
</div>
<div class="paragraph">
<p>This default execution model is usually preferrable because it don&#8217;t abuse
task scheduling and leverages function inlining on the JVM.</p>
</div>
<div class="paragraph">
<p>But it does have drawbacks: this approach will block the thread until
all of the chained callbacks are executed. For small chains this is not a
problem. However, if your chain has a lot of functions and requires a
lot of computation time, this might cause unexpected latency. It may block
other threads in the thread pool from doing other, maybe more important,
tasks.</p>
</div>
<div class="paragraph">
<p>For such cases, <strong>promesa</strong> exposes an additional arity for provide a
user-defined executor to control where the chained callbacks are executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.exec</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>

<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nb">inc </span><span class="tok-nv">exec/default-executor</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nb">inc </span><span class="tok-nv">exec/default-executor</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will schedule a separated task for each chained callback, making
the whole system more responsive because you are no longer executing
big blocking functions; instead you are executing many small tasks.</p>
</div>
<div class="paragraph">
<p>The <code>exec/default-executor</code> is a <code>ForkJoinPool</code> instance that is highly
optimized for lots of small tasks.</p>
</div>
<div class="paragraph">
<p>In some cases you may still want execute all chained functions
together but all together in different executor. In this case you can
use the <code>deferred</code> constructor to specify the executor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/delay</span> <span class="tok-mi">100</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/deferred</span> <span class="tok-nv">exec/default-executor</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/chain</span><span class="tok-o">&#39;</span> <span class="tok-nb">inc </span><span class="tok-nv">inc</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="performance-overhead"><a class="link" href="#performance-overhead">Performance overhead</a></h3>
<div class="paragraph">
<p>The <strong>promesa</strong> is a lightweight abstraction built on top of native
abstractions (<code>CompletableFuture</code> in the jvm and <code>js/Promise</code> on
cljs).</p>
</div>
<div class="paragraph">
<p>Internaly we have heavy use of protocols in order to expose a
polimorphic and user friendly api, but this have a little overhead on
top of raw usage of <code>CompletableFuture</code> or <code>Promise</code>. This is the
latest micro benchmark (2019-09-17) that shows the real overhead of
this library in contrat to use plain native abstractions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">run-bench</span> <span class="tok-p">(</span><span class="tok-nf">simple-promise-chain-5-raw</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; amd64 Linux 5.2.9-arch1-1-ARCH 4 cpu(s)</span>
<span class="tok-c1">;; =&gt; OpenJDK 64-Bit Server VM 12.0.2+10</span>
<span class="tok-c1">;; =&gt; Runtime arguments: -Dclojure.compiler.direct-linking=true</span>
<span class="tok-c1">;; =&gt; Evaluation count : 687647820 in 60 samples of 11460797 calls.</span>
<span class="tok-c1">;; =&gt;       Execution time sample mean : 82.617649 ns</span>
<span class="tok-c1">;; =&gt;              Execution time mean : 82.606811 ns</span>
<span class="tok-c1">;; =&gt; Execution time sample std-deviation : 2.348589 ns</span>
<span class="tok-c1">;; =&gt;     Execution time std-deviation : 2.365164 ns</span>
<span class="tok-c1">;; =&gt;    Execution time lower quantile : 78.787962 ns ( 2.5%)</span>
<span class="tok-c1">;; =&gt;    Execution time upper quantile : 86.941501 ns (97.5%)</span>
<span class="tok-c1">;; =&gt;                    Overhead used : 9.967315 ns</span>
<span class="tok-c1">;; =&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">run-bench</span> <span class="tok-p">(</span><span class="tok-nf">simple-completable-chain-5-raw</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; amd64 Linux 5.2.9-arch1-1-ARCH 4 cpu(s)</span>
<span class="tok-c1">;; =&gt; OpenJDK 64-Bit Server VM 12.0.2+10</span>
<span class="tok-c1">;; =&gt; Runtime arguments: -Dclojure.compiler.direct-linking=true</span>
<span class="tok-c1">;; =&gt; Evaluation count : 823532160 in 60 samples of 13725536 calls.</span>
<span class="tok-c1">;; =&gt;       Execution time sample mean : 62.267034 ns</span>
<span class="tok-c1">;; =&gt;              Execution time mean : 62.279349 ns</span>
<span class="tok-c1">;; =&gt; Execution time sample std-deviation : 1.967931 ns</span>
<span class="tok-c1">;; =&gt;     Execution time std-deviation : 2.014908 ns</span>
<span class="tok-c1">;; =&gt;    Execution time lower quantile : 59.663843 ns ( 2.5%)</span>
<span class="tok-c1">;; =&gt;    Execution time upper quantile : 67.599822 ns (97.5%)</span>
<span class="tok-c1">;; =&gt;                    Overhead used : 9.967315 ns</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The benchmarked functions are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">simple-promise-chain-5-raw</span>
  <span class="tok-p">[]</span>
  <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">as-&gt;</span> <span class="tok-p">(</span><span class="tok-nf">CompletableFuture/completedFuture</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">$</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">$</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">$</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">$</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">$</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">p/then</span><span class="tok-o">&#39;</span> <span class="tok-nv">$</span> <span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">simple-completable-chain-5-raw</span>
  <span class="tok-p">[]</span>
  <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">as-&gt;</span> <span class="tok-p">(</span><span class="tok-nf">CompletableFuture/completedFuture</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">$</span>
     <span class="tok-p">(</span><span class="tok-nf">.thenApply</span> <span class="tok-o">^</span><span class="tok-nv">CompletionStage</span> <span class="tok-nv">$</span> <span class="tok-o">^</span><span class="tok-nv">Function</span> <span class="tok-p">(</span><span class="tok-nf">pu/-&gt;FunctionWrapper</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
     <span class="tok-p">(</span><span class="tok-nf">.thenApply</span> <span class="tok-o">^</span><span class="tok-nv">CompletionStage</span> <span class="tok-nv">$</span> <span class="tok-o">^</span><span class="tok-nv">Function</span> <span class="tok-p">(</span><span class="tok-nf">pu/-&gt;FunctionWrapper</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
     <span class="tok-p">(</span><span class="tok-nf">.thenApply</span> <span class="tok-o">^</span><span class="tok-nv">CompletionStage</span> <span class="tok-nv">$</span> <span class="tok-o">^</span><span class="tok-nv">Function</span> <span class="tok-p">(</span><span class="tok-nf">pu/-&gt;FunctionWrapper</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
     <span class="tok-p">(</span><span class="tok-nf">.thenApply</span> <span class="tok-o">^</span><span class="tok-nv">CompletionStage</span> <span class="tok-nv">$</span> <span class="tok-o">^</span><span class="tok-nv">Function</span> <span class="tok-p">(</span><span class="tok-nf">pu/-&gt;FunctionWrapper</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
     <span class="tok-p">(</span><span class="tok-nf">.thenApply</span> <span class="tok-o">^</span><span class="tok-nv">CompletionStage</span> <span class="tok-nv">$</span> <span class="tok-o">^</span><span class="tok-nv">Function</span> <span class="tok-p">(</span><span class="tok-nf">pu/-&gt;FunctionWrapper</span> <span class="tok-nv">inc</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developers-guide"><a class="link" href="#developers-guide">Developers Guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="contributing"><a class="link" href="#contributing">Contributing</a></h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contrib libs, this project does not have many restrictions for
contributions. Just open a issue or pull request.</p>
</div>
</div>
<div class="sect2">
<h3 id="get-the-code"><a class="link" href="#get-the-code">Get the Code</a></h3>
<div class="paragraph">
<p><em>promesa</em> is open source and can be found on
<a href="https://github.com/funcool/promesa">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>git clone https://github.com/funcool/promesa</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run-tests"><a class="link" href="#run-tests">Run tests</a></h3>
<div class="paragraph">
<p>To run the tests execute the following:</p>
</div>
<div class="paragraph">
<p>For the JVM platform:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>lein test</code></pre>
</div>
</div>
<div class="paragraph">
<p>And for JS platform:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>./scripts/build
node out/tests.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will need to have nodejs installed on your system.</p>
</div>
</div>
<div class="sect2">
<h3 id="license"><a class="link" href="#license">License</a></h3>
<div class="paragraph">
<p><em>promesa</em> is licensed under BSD (2-Clause) license:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Copyright (c) 2015-2019 Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-10-01 17:19:45 +0200
</div>
</div>
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments  { background: #f0f0f0; }
pre.pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #60a0b0; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #007020 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #60a0b0; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #902000 } /* Keyword.Type */
pre.pygments .tok-m { color: #40a070 } /* Literal.Number */
pre.pygments .tok-s { color: #4070a0 } /* Literal.String */
pre.pygments .tok-na { color: #4070a0 } /* Name.Attribute */
pre.pygments .tok-nb { color: #007020 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #60add5 } /* Name.Constant */
pre.pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
pre.pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #007020 } /* Name.Exception */
pre.pygments .tok-nf { color: #06287e } /* Name.Function */
pre.pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
pre.pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
pre.pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #4070a0 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #4070a0 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
pre.pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #06287e } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #bb60d5 } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
</body>
</html>