<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Channels (CSP pattern)</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Promesa</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="promises.html"><div class="inner"><span>Working with Promises</span></div></a></li><li class="depth-1 "><a href="executors.html"><div class="inner"><span>Scheduling &amp; Executors</span></div></a></li><li class="depth-1  current"><a href="channels.html"><div class="inner"><span>Channels (CSP pattern)</span></div></a></li><li class="depth-1 "><a href="bulkhead.html"><div class="inner"><span>Bulkhead (concurrency limiter)</span></div></a></li><li class="depth-1 "><a href="contributing.html"><div class="inner"><span>Contributing</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>promesa</span></div></div></li><li class="depth-2 branch"><a href="promesa.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="promesa.exec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exec</span></div></a></li><li class="depth-3 branch"><a href="promesa.exec.bulkhead.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bulkhead</span></div></a></li><li class="depth-3"><a href="promesa.exec.csp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csp</span></div></a></li><li class="depth-2"><a href="promesa.protocols.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#channels-csp-pattern" id="channels-csp-pattern"></a>Channels (CSP pattern)</h1>
<p>A <a href="https://github.com/clojure/core.async">core.async</a> alternative implementation that laverages JDK19 Virtual Threads; therefore, it is mainly available in the JVM. It combines a new and simplified channel implementation, JDK virtual thrads and composability of promises (CompletableFutureâ€™s).</p>
<p>There are <a href="https://github.com/funcool/promesa/blob/master/doc/csp-walkthrought.clj">Code Walkthrought</a> where you can learn the main API usage patterns. Also, you can read the <a href="https://clojure.org/news/2013/06/28/clojure-clore-async-channels">core.async rationale</a> for better understanding the main ideas of the CSP pattern.</p>
<p>The main highlights and differences with <a href="https://github.com/clojure/core.async">core.async</a> are:</p>
<ul>
<li><strong>There are no macro transformations</strong>, the <code>go</code> macro is a convenient alias for <code>p/vthread</code> (or <code>p/thread</code> when vthreads are not available); there are not limitation on using blocking calls inside <code>go</code> macro neither many other inconveniences of core.async go macro, mainly thanks to the JDK19 with preview enabled Virtual Threads.</li>
<li><strong>No callbacks</strong>, functions returns promises or blocks.</li>
<li><strong>No take/put limits</strong>; you can attach more than 1024 pending tasks to a channel.</li>
<li><strong>Simplier mental model</strong>, there are no differences between parking and blocking operations.</li>
<li><strong>Analogous performance</strong>; in my own stress tests it has the same performance as core.async.</li>
</ul>
<p>There are also some internal differences that you should know:</p>
<ul>
<li>The promesa implementation cancells immediatelly all pending puts when channel is closed in contrast to core.async that leaves them operative until all puts are succeded.</li>
<li>The promesa implementation takes a bit less grandular locking than core.async, but on the end it should not have any effect on the final performance or usability.</li>
</ul>
<p><strong>The promesa channel and csp patterns implementation do not intend to be a replacement for core.async; and there are cases where <a href="https://github.com/clojure/core.async">core.async</a> is preferable; the main usage target for promesa channels and csp patterns implementation is for JVM based backends with JDK&gt;=19.</strong></p>
<p><strong>Although the main focus is the use in JVM, where is all the potential; the channel implementation and all internal buffers are implemented in CLJC. This means that, if there is interest, we can think about exposing channels api using promises. In any case, <em>the usefulness of channel implementation in CLJS remains to be seen.</em></strong></p>
</div></div></div></body></html>