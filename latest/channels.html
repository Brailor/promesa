<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Channels (CSP pattern)</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Promesa</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="promises.html"><div class="inner"><span>Working with Promises</span></div></a></li><li class="depth-1 "><a href="executors.html"><div class="inner"><span>Scheduling &amp; Executors</span></div></a></li><li class="depth-1  current"><a href="channels.html"><div class="inner"><span>Channels (CSP pattern)</span></div></a></li><li class="depth-1 "><a href="bulkhead.html"><div class="inner"><span>Bulkhead (concurrency limiter)</span></div></a></li><li class="depth-1 "><a href="contributing.html"><div class="inner"><span>Contributing</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>promesa</span></div></div></li><li class="depth-2 branch"><a href="promesa.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="promesa.exec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exec</span></div></a></li><li class="depth-3 branch"><a href="promesa.exec.bulkhead.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bulkhead</span></div></a></li><li class="depth-3"><a href="promesa.exec.csp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csp</span></div></a></li><li class="depth-2"><a href="promesa.protocols.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#channels-csp-pattern" id="channels-csp-pattern"></a>Channels (CSP pattern)</h1>
<p>An implementation of channel abstraction and CSP patterns for Clojure; is a <a href="https://github.com/clojure/core.async">core.async</a> alternative implementation that laverages JDK19 Virtual Threads.</p>
<p>There are <a href="https://github.com/funcool/promesa/blob/master/doc/csp-walkthrought.clj">Code Walkthrought</a> where you can learn the main API usage patterns. Also, you can read the <a href="https://clojure.org/news/2013/06/28/clojure-clore-async-channels">core.async rationale</a> for better understanding the main ideas of the CSP pattern.</p>
<p>The promesa channel and csp patterns implementation do not intend to be a replacement for core.async; and there are cases where <a href="https://github.com/clojure/core.async">core.async</a> is preferable; the main usage target for promesa channels and csp patterns implementation is for JVM based backends with JDK&gt;=19.</p>
<p><strong>NOTE: Although the main focus is the use in JVM, where is all the potential; the channel implementation and all internal buffers are implemented in CLJC. This means that, if there is interest, we can think about exposing channels API using promises. In any case, <em>the usefulness of channel implementation in CLJS remains to be seen.</em></strong></p>
<h2><a href="#differences-with-coreasync" id="differences-with-coreasync"></a>Differences with <code>core.async</code></h2>
<p>The main highlights and differences with <a href="https://github.com/clojure/core.async">core.async</a> are:</p>
<ul>
<li><strong>There are no macro transformations</strong>, the <code>go</code> macro is a convenient alias for <code>p/vthread</code> (or <code>p/thread</code> when vthreads are not available); there are not limitation on using blocking calls inside <code>go</code> macro neither many other inconveniences of core.async go macro, mainly thanks to the JDK19 with preview enabled Virtual Threads.</li>
<li><strong>No callbacks</strong>, functions returns promises or blocks; you can use the promise composition API or thread blocking API, whatever you wants.</li>
<li><strong>No take/put limits</strong>; you can attach more than 1024 pending tasks to a channel.</li>
<li><strong>Simplier mental model</strong>, there are no differences between parking and blocking operations.</li>
<li><strong>Analogous performance</strong>; in my own stress tests it has the same performance as core.async.</li>
</ul>
<p>There are also some internal differences that you should know:</p>
<ul>
<li>The promesa implementation cancells immediatelly all pending puts when channel is closed in contrast to core.async that leaves them operative until all puts are succeded.</li>
<li>The promesa implementation takes a bit less grandular locking than core.async, but on the end it should not have any effect on the final performance or usability.</li>
<li>The <code>promesa.exec.csp/pipe</code> helper does not uses go-blocks, so it can be safelly used with no-vthreads support because it will not create additional platform threads.</li>
</ul>
<h2><a href="#getting-started" id="getting-started"></a>Getting Started</h2>
<p>This documentation supposes you have some knowledge of core.async API.</p>
<h4><a href="#working-with-channels-api" id="working-with-channels-api"></a>Working with channels API</h4>
<p>Lets create a channel and put value in-to:</p>
<pre><code class="language-clojure">(require '[promesa.exec.csp :as sp])

(def ch (sp/chan 2))

;; perform a blocking put operation using a blocking operation
(sp/put! ch :a)
;; =&gt; true

;; Or perform a blocking put operation using `put` function
;; that returns a promise/future-like object (CompletableFuture)
@(sp/put ch :b)
;; =&gt; true
</code></pre>
<p>Now, lets try to retrieve data from channel:</p>
<pre><code class="language-clojure">;; Using a blocking helper, analogous to clojure.core.async/&lt;!!
(sp/take! ch)
;; =&gt; :a

;; Or blocking on promise
@(sp/take ch)
;; =&gt; :b
</code></pre>
<p>You also can take with timeout:</p>
<pre><code class="language-clojure">@(sp/take ch 1000 :not-found)
;; =&gt; :not-found
</code></pre>
<p>For convenience and <code>core.async</code> familiarity, there are also <code>&lt;!</code> and <code>&gt;!</code> functions that have the same api as their counterpart <code>take!</code> and <code>put!</code></p>
<h4><a href="#the-go-blocks" id="the-go-blocks"></a>The go blocks</h4>
<p>Now, knowing how channels works, let’s start with <code>go</code> blocks.</p>
<p>In contrast to <code>core.async</code>, the promesa go blocks are just virtual threads (or standard threads if the vthreads are not available) so there are no macro limitations nor blocking/parking differences.</p>
<p>The promesa go blocks returns promises (CompletableFuture’s) instead of channels. This is because the code on go block can fail and channels are bad abstraction for represent a computation result that can fail.</p>
<pre><code class="language-clojure">@(sp/go
   (sp/&lt;! ch 1000 :timeout))
;; =&gt; :timeout
</code></pre>
<p>But if you need a channel, there are <code>go-chan</code> macro. The <code>go</code> + <code>loop</code> macro is also available as <code>go-loop</code>.</p>
<h4><a href="#multiple-operations" id="multiple-operations"></a>Multiple Operations</h4>
<p>If you want perform multiple operations on the same or mutliple channels. In the same line as <code>clojure.core.async/alts!!</code>, this library exposes the <code>promesa.exec.csp/alts!</code> macro that has the same API:</p>
<pre><code class="language-clojure">(let [c1 (sp/chan)
      c2 (sp/chan)]
  (sp/go-loop []
    (let [[v ch] (sp/alts! [c1 c2])]
      (when v
        (println "Read" v "from" ch)
        (recur))))

  @(sp/go
     (sp/&gt;! c1 "hi")
     (sp/&gt;! c2 "there")
     (sp/close! c1)
     (sp/close! c2)))

;; Prints (on stdout):
;;   Read hi from #&lt;promesa.exec.csp.channel.Channel ...&gt;
;;   Read there from #&lt;promesa.exec.csp.channel.Channel ...&gt;
</code></pre>
<p>For completeness, there are also <code>alts</code> function, that returns a <code>CompletableFuture</code> instead of blocking the current thread.</p>
<h4><a href="#channel-multiplexing" id="channel-multiplexing"></a>Channel multiplexing</h4>
<p>There are some situations when you want multiple readers on the same data or implement some kind of pub/sub. For this reason we have the multiplexed channel constructors: <code>mult</code> and <code>mult*</code>.</p>
<pre><code class="language-clojure">(def mx (sp/mult))

(a/go
  (let [ch (sp/chan)]
    (sp/tap! mx ch)
    (println "go 1:" (sp/&lt;! ch))
    (sp/close! ch)))

(a/go
  (let [ch (sp/chan)]
    (sp/tap! mx ch)
    (println "go 2:" (sp/&lt;! ch))
    (sp/close! ch)))

(sp/&gt;! mx :a)

;; Will print to stdout (maybe in different order)
;;   go 1: :a
;;   go 2: :a
</code></pre>
<p>The <code>mult</code> constructor returns a muliplexer, and as it implements the channel API, you can put values in directly. For the cases when you already have a channel that you want multiplext, just use the <code>mult*</code>.</p>
<p>The <code>mult*</code> works in the same way as <code>clojure.core.async/mult</code>.  There are also <code>untap!</code> function for removing the channel from the multiplexer.</p>
<p>Closed channels are automatically removed from the multiplexer.</p>
</div></div></div></body></html>