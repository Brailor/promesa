<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Scheduling &amp; Executors</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Promesa</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1 "><a href="promises.html"><div class="inner"><span>Working with Promises</span></div></a></li><li class="depth-1  current"><a href="executors.html"><div class="inner"><span>Scheduling &amp; Executors</span></div></a></li><li class="depth-1 "><a href="channels.html"><div class="inner"><span>Channels (CSP pattern)</span></div></a></li><li class="depth-1 "><a href="bulkhead.html"><div class="inner"><span>Bulkhead (concurrency limiter)</span></div></a></li><li class="depth-1 "><a href="contributing.html"><div class="inner"><span>Contributing</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>promesa</span></div></div></li><li class="depth-2 branch"><a href="promesa.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="promesa.exec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exec</span></div></a></li><li class="depth-3 branch"><a href="promesa.exec.bulkhead.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bulkhead</span></div></a></li><li class="depth-3"><a href="promesa.exec.csp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csp</span></div></a></li><li class="depth-2"><a href="promesa.protocols.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#scheduling-executors" id="scheduling-executors"></a>Scheduling &amp; Executors</h1>
<h2><a href="#introduction" id="introduction"></a>Introduction</h2>
<p>Additionally to the <em>promise</em> abstraction, <strong>promesa</strong> library comes with many helpers and factories for execution and scheduling of tasks for asynchronous execution.</p>
<p>Although this API works in the JS runtime and some of the function has general utility, the main target is the JVM platform.</p>
<h2><a href="#async-tasks" id="async-tasks"></a>Async Tasks</h2>
<p>Firstly, lets define <strong>async task</strong>: a function that is executed out of current flow using a different thread. Here, <strong>promesa</strong> library exposes mainly two functions:</p>
<ul>
<li><code>promesa.exec/run!</code>: useful when you want run a function in a different thread and you don’t care abour the return value; it returns a promise that will be fullfilled when the callback terminates.</li>
<li><code>promesa.exec/submit!</code> useful when you want run a function in a different thread and you need the return value; it returns a promise that will be fullfilled with the return value of the function.</li>
</ul>
<p>Let see some examples:</p>
<pre><code class="language-clojure">(require '[promesa.exec :as px])


@(px/run! (fn []
            (prn "I'm running in different thread")
            1))
;; =&gt; nil

@(px/submit! (fn []
               (prn "I'm running in different thread")
               1))
;; =&gt; 1
</code></pre>
<p>The both functions optionally accepts as first argument an executor instance that allows specify the executor where you want execute the specified function. If no executor is provided, the default one is used (binded on the <code>promesa.exec/*default-executor*</code> dynamic var).</p>
<p>Also, in both cases, the returned promise is cancellable, so if for some reason the function is still not execued, the cancellation will prevent the execution. You can cancel a cancellable promise with <code>p/cancel!</code> function.</p>
<h2><a href="#delayed-tasks" id="delayed-tasks"></a>Delayed Tasks</h2>
<p>This consists in a simple helper that allows scheduling execution of a function after some amount of time.</p>
<pre><code class="language-clojure">(require '[promesa.exec :as exec])
(exec/schedule! 1000 (fn []
                       (println "hello world")))
</code></pre>
<p>This example shows you how you can schedule a function call to be executed 1 second in the future. It works the same way for both Clojure and ClojureScript.</p>
<p>The tasks can be cancelled using its return value:</p>
<pre><code class="language-clojure">(def task (exec/schedule! 1000 #(do-stuff)))

(p/cancel! task)
</code></pre>
<p>The execution model depends on the platform: on the <strong>JVM</strong> a default scheduler executor is used and the the scheduled function will be executed in different thread; on <strong>JS</strong> runtime the function will be executed in a <em>microtask</em>.</p>
<h2><a href="#executors-factories" id="executors-factories"></a>Executors Factories</h2>
<p>A collection of factories function for create executors instances (JVM only):</p>
<ul>
<li><code>px/cached-executor</code>: creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available.</li>
<li><code>px/fixed-executor</code>: creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.</li>
<li><code>px/single-executor</code>: creates an Executor that uses a single worker thread operating off an unbounded queue</li>
<li><code>px/scheduled-executor</code>: creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</li>
<li><code>px/forkjoin-executor</code>: creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention.</li>
</ul>
<p>Since v9.0.x there are new factories that uses the JDK&gt;=19 preview API:</p>
<ul>
<li><code>px/thread-per-task-executor</code>: creates an Executor that starts a new Thread for each task.</li>
<li><code>px/vthread-per-task-executor</code>: creates an Executor that starts a new virtual Thread for each task.</li>
</ul>
<h2><a href="#helpers" id="helpers"></a>Helpers</h2>
<h3><a href="#pmap-experimental" id="pmap-experimental"></a><code>pmap</code> (experimental)</h3>
<p>This is a simplified <code>clojure.core/pmap</code> analogous function that allows execute a potentially computationally expensive or io bound functions in parallell.</p>
<p>It returns a lazy chunked seq (uses the clojure’s default chunk size: 32) and the maximum parallelism is determined by the provided executor.</p>
<p>Example:</p>
<pre><code class="language-clojure">(defn slow-inc
  [x]
  (Thread/sleep 1000)
  (inc x))

(time
 (doall
  (px/pmap slow-inc (range 10))))

;; "Elapsed time: 2002.724345 msecs"
;; =&gt; (1 2 3 4 5 6 7 8 9 10)

(time
 (doall
  (map slow-inc (range 10))))

;; Elapsed time: 10001.912614 msecs"
;; =&gt; (1 2 3 4 5 6 7 8 9 10)
</code></pre>
<h3><a href="#with-executor-macro-experimental" id="with-executor-macro-experimental"></a><code>with-executor</code> macro (experimental)</h3>
<p>This allows run a scoped code with the <code>px/*default-executor*</code> binded to the provided executor. The provided executor can be a function for lazy executor instantiation.</p>
<p>It optionally accepts metadata on the executor part for indicate:</p>
<ul>
<li><code>^:shutdown</code>: shutdown the pool before return</li>
<li><code>^:interrupt</code>: shutdown and interrupt before return</li>
</ul>
<p>There an example on how you can customize the executor for <strong>pmap</strong>:</p>
<pre><code class="language-clojure">(time
 (px/with-executor ^:shutdown (px/fixed-executor :parallelism 2)
   (doall (px/pmap slow-inc (range 10)))))

;; "Elapsed time: 5004.506274 msecs"
;; =&gt; (1 2 3 4 5 6 7 8 9 10)
</code></pre>
</div></div></div></body></html>